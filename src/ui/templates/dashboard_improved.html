<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Equity Research Tool | Dashboard</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js" integrity="sha384-IpsGuF7Hw6elkalSyi005ZbPFFntkbDE5jBqFaUG2RMaxSelD+spQdLsiyeq9z8o" crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script>
        // Enhanced configuration management
        class DashboardConfig {
            constructor() {
                this.API_BASE = '';
                this.SEARCH_DEBOUNCE_MS = 300;
                this.CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes
                this.MAX_RETRY_ATTEMPTS = 3;
                this.RETRY_DELAY_MS = 1000;
                this.WATCHLIST_UPDATE_INTERVAL_MS = 30000; // 30 seconds
                this.DEFAULT_TICKERS = []; // Will be loaded dynamically
                this.REQUEST_TIMEOUT_MS = 10000; // 10 seconds
            }

            async loadDefaults() {
                try {
                    const response = await this.fetchWithTimeout('/api/default_tickers', {
                        timeout: this.REQUEST_TIMEOUT_MS
                    });
                    if (response.ok) {
                        const data = await response.json();
                        this.DEFAULT_TICKERS = data.tickers || ['AAPL', 'MSFT', 'GOOGL', 'TSLA', 'AMZN'];
                    }
                } catch (error) {
                    console.warn('Failed to load default tickers:', error);
                    this.DEFAULT_TICKERS = ['AAPL', 'MSFT', 'GOOGL', 'TSLA', 'AMZN'];
                }
            }

            fetchWithTimeout(url, options = {}) {
                const timeout = options.timeout || this.REQUEST_TIMEOUT_MS;
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                return fetch(url, {
                    ...options,
                    signal: controller.signal
                }).finally(() => clearTimeout(timeoutId));
            }
        }

        // Enhanced cache management with TTL
        class CacheManager {
            constructor(ttlMs = 5 * 60 * 1000) {
                this.cache = new Map();
                this.ttlMs = ttlMs;
            }

            set(key, value) {
                this.cache.set(key, {
                    value,
                    timestamp: Date.now()
                });
            }

            get(key) {
                const entry = this.cache.get(key);
                if (!entry) return null;

                if (Date.now() - entry.timestamp > this.ttlMs) {
                    this.cache.delete(key);
                    return null;
                }

                return entry.value;
            }

            clear() {
                this.cache.clear();
            }

            has(key) {
                const entry = this.cache.get(key);
                if (!entry) return false;

                if (Date.now() - entry.timestamp > this.ttlMs) {
                    this.cache.delete(key);
                    return false;
                }

                return true;
            }
        }

        // Enhanced API request manager with cancellation and retry
        class APIManager {
            constructor(config) {
                this.config = config;
                this.cache = new CacheManager(config.CACHE_TTL_MS);
                this.pendingRequests = new Map();
            }

            async request(url, options = {}) {
                const cacheKey = `${url}${JSON.stringify(options)}`;

                // Check cache first for GET requests
                if (!options.method || options.method === 'GET') {
                    const cached = this.cache.get(cacheKey);
                    if (cached) {
                        return cached;
                    }
                }

                // Cancel previous request if same URL is requested
                if (this.pendingRequests.has(url)) {
                    this.pendingRequests.get(url).abort();
                }

                const controller = new AbortController();
                this.pendingRequests.set(url, controller);

                try {
                    const response = await this.retryRequest(url, {
                        ...options,
                        signal: controller.signal
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();

                    // Cache successful GET responses
                    if (!options.method || options.method === 'GET') {
                        this.cache.set(cacheKey, data);
                    }

                    return data;
                } finally {
                    this.pendingRequests.delete(url);
                }
            }

            async retryRequest(url, options, attempt = 1) {
                try {
                    return await this.config.fetchWithTimeout(url, options);
                } catch (error) {
                    if (attempt < this.config.MAX_RETRY_ATTEMPTS && !options.signal?.aborted) {
                        await this.delay(this.config.RETRY_DELAY_MS * attempt);
                        return this.retryRequest(url, options, attempt + 1);
                    }
                    throw error;
                }
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            cancelAll() {
                for (const controller of this.pendingRequests.values()) {
                    controller.abort();
                }
                this.pendingRequests.clear();
            }
        }

        // Market status tracker
        class MarketStatus {
            constructor() {
                this.isOpen = false;
                this.nextOpen = null;
                this.nextClose = null;
                this.timezone = 'America/New_York';
            }

            async updateStatus() {
                try {
                    const response = await fetch('/api/market_status');
                    if (response.ok) {
                        const data = await response.json();
                        this.isOpen = data.is_open;
                        this.nextOpen = data.next_open;
                        this.nextClose = data.next_close;
                        this.updateUI();
                    }
                } catch (error) {
                    console.warn('Failed to update market status:', error);
                }
            }

            updateUI() {
                const element = document.getElementById('marketStatus');
                if (!element) return;

                const status = this.isOpen ? 'OPEN' : 'CLOSED';
                const statusClass = this.isOpen ? 'text-green-600' : 'text-red-600';
                const time = this.isOpen ? this.nextClose : this.nextOpen;

                element.innerHTML = `
                    <span class="font-semibold ${statusClass}">${status}</span>
                    ${time ? `<span class="text-xs text-gray-500 ml-2">Next: ${new Date(time).toLocaleTimeString()}</span>` : ''}
                `;
            }
        }

        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            DEFAULT: 'hsl(222.2, 47.4%, 11.2%)',
                            foreground: 'hsl(210, 40%, 98%)'
                        },
                        background: 'hsl(0, 0%, 100%)',
                        foreground: 'hsl(222.2, 84%, 4.9%)',
                        card: 'hsl(0, 0%, 100%)',
                        'card-foreground': 'hsl(222.2, 84%, 4.9%)',
                        muted: 'hsl(210, 40%, 96.1%)',
                        'muted-foreground': 'hsl(215.4, 16.3%, 46.9%)',
                        border: 'hsl(214.3, 31.8%, 91.4%)',
                        success: '#16a34a',
                        danger: '#dc2626',
                        warning: '#f59e0b',
                        dark: {
                            primary: {
                                DEFAULT: 'hsl(210, 40%, 98%)',
                                foreground: 'hsl(222.2, 47.4%, 11.2%)'
                            },
                            background: 'hsl(222.2, 84%, 4.9%)',
                            foreground: 'hsl(210, 40%, 98%)',
                            card: 'hsl(222.2, 84%, 4.9%)',
                            'card-foreground': 'hsl(210, 40%, 98%)',
                            muted: 'hsl(217.2, 32.6%, 17.5%)',
                            'muted-foreground': 'hsl(215, 20.2%, 65.1%)',
                            border: 'hsl(217.2, 32.6%, 17.5%)',
                            success: '#22c55e',
                            danger: '#ef4444',
                            warning: '#f59e0b'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: hsl(215.4, 16.3%, 70%); border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb { background: hsl(215, 20.2%, 40%); }

        .ticker-container {
            overflow: hidden;
            position: relative;
        }

        .ticker-track {
            display: flex;
            gap: 1.25rem;
            width: max-content;
            animation: ticker-scroll 35s linear infinite;
        }

        .ticker-track:hover {
            animation-play-state: paused;
        }

        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .loading-shimmer {
            background: linear-gradient(90deg, #f0f0f0 25%, transparent 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
    </style>
</head>
<body class="bg-background dark:bg-dark-background text-foreground dark:text-dark-foreground font-sans antialiased">
    <!-- Enhanced JavaScript functionality starts here -->
    <script>
        // Global state management
        let config = new DashboardConfig();
        let apiManager = new APIManager(config);
        let marketStatus = new MarketStatus();
        let socket = null;
        let searchCache = new Map();
        let debounceTimer = null;
        let watchlist = [];
        let activeReports = {};
        let recentReports = [];

        // Enhanced search functionality
        class SearchManager {
            constructor(apiManager, config) {
                this.apiManager = apiManager;
                this.config = config;
                this.cache = new CacheManager(config.CACHE_TTL_MS);
            }

            async search(query) {
                if (!query || query.length < 2) return [];

                const cacheKey = query.toUpperCase();
                const cached = this.cache.get(cacheKey);
                if (cached) return cached;

                try {
                    const data = await this.apiManager.request(`/api/search_tickers?q=${encodeURIComponent(query)}`);
                    this.cache.set(cacheKey, data);
                    return data;
                } catch (error) {
                    console.error('Search failed:', error);
                    return [];
                }
            }

            renderResults(matches, container, query) {
                if (!container) return;

                const list = container.querySelector('ul');
                if (!list) return;

                if (matches.length === 0) {
                    list.innerHTML = '<li class="px-3 py-2 text-muted-foreground dark:text-dark-muted-foreground">No results found</li>';
                    return;
                }

                const queryRegex = new RegExp(`(${query})`, 'gi');
                list.innerHTML = matches.map((item, index) => {
                    const highlightedName = item.name ? item.name.replace(queryRegex, '<mark class="bg-yellow-200 dark:bg-yellow-900">$1</mark>') : '';
                    const highlightedTicker = item.ticker ? item.ticker.replace(queryRegex, '<mark class="bg-yellow-200 dark:bg-yellow-900">$1</mark>') : '';

                    return `
                        <li class="px-3 py-2 hover:bg-muted dark:hover:bg-dark-muted cursor-pointer border-b border-border dark:border-dark-border last:border-b-0"
                            data-ticker="${item.ticker}"
                            onclick="selectSearchResult('${item.ticker}')">
                            <div class="flex items-center justify-between">
                                <div>
                                    <div class="font-semibold text-foreground dark:text-dark-foreground">${highlightedTicker}</div>
                                    <div class="text-sm text-muted-foreground dark:text-dark-muted-foreground">${highlightedName}</div>
                                    ${item.sector ? `<div class="text-xs text-muted-foreground dark:text-dark-muted-foreground">${item.sector}</div>` : ''}
                                </div>
                                <div class="text-right">
                                    ${item.price ? `<div class="font-semibold text-foreground dark:text-dark-foreground">$${item.price.toFixed(2)}</div>` : ''}
                                    ${item.percent_change !== undefined ? `
                                        <div class="text-sm ${item.percent_change >= 0 ? 'text-success' : 'text-danger'}">
                                            ${item.percent_change >= 0 ? '+' : ''}${item.percent_change.toFixed(2)}%
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="mt-2 flex items-center gap-3">
                                <button class="text-xs font-semibold text-primary dark:text-dark-primary hover:underline"
                                        onclick="event.stopPropagation(); showQuickView('${item.ticker}')">Quick View</button>
                                <button class="text-xs font-semibold text-primary dark:text-dark-primary hover:underline"
                                        onclick="event.stopPropagation(); addToWatchlist('${item.ticker}')">Add to Watchlist</button>
                                <button class="text-xs font-semibold text-primary dark:text-dark-primary hover:underline"
                                        onclick="event.stopPropagation(); generateReport('${item.ticker}')">Generate Report</button>
                            </div>
                        </li>
                    `;
                }).join('');
            }
        }

        // Enhanced watchlist management
        class WatchlistManager {
            constructor(apiManager) {
                this.apiManager = apiManager;
                this.updateInterval = null;
                this.watchlist = this.loadWatchlist();
            }

            loadWatchlist() {
                try {
                    return JSON.parse(localStorage.getItem('ert_watchlist') || '[]');
                } catch {
                    return [];
                }
            }

            saveWatchlist() {
                localStorage.setItem('ert_watchlist', JSON.stringify(this.watchlist));
            }

            add(ticker) {
                if (!this.watchlist.includes(ticker.toUpperCase())) {
                    this.watchlist.push(ticker.toUpperCase());
                    this.saveWatchlist();
                    this.updateUI();
                    return true;
                }
                return false;
            }

            remove(ticker) {
                const index = this.watchlist.indexOf(ticker.toUpperCase());
                if (index > -1) {
                    this.watchlist.splice(index, 1);
                    this.saveWatchlist();
                    this.updateUI();
                    return true;
                }
                return false;
            }

            async updatePrices() {
                if (this.watchlist.length === 0) return;

                try {
                    const data = await this.apiManager.request('/api/watchlist_prices', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ tickers: this.watchlist })
                    });

                    this.updatePriceDisplay(data);
                } catch (error) {
                    console.error('Failed to update watchlist prices:', error);
                }
            }

            updatePriceDisplay(priceData) {
                const container = document.getElementById('watchlistContainer');
                if (!container) return;

                this.watchlist.forEach(ticker => {
                    const element = container.querySelector(`[data-watchlist-ticker="${ticker}"]`);
                    if (!element || !priceData[ticker]) return;

                    const priceElement = element.querySelector('.watchlist-price');
                    const changeElement = element.querySelector('.watchlist-change');

                    if (priceElement && priceData[ticker].price) {
                        priceElement.textContent = `$${priceData[ticker].price.toFixed(2)}`;
                    }

                    if (changeElement && priceData[ticker].percent_change !== undefined) {
                        const change = priceData[ticker].percent_change;
                        changeElement.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                        changeElement.className = `watchlist-change text-sm ${change >= 0 ? 'text-success' : 'text-danger'}`;
                    }
                });
            }

            updateUI() {
                const container = document.getElementById('watchlistContainer');
                if (!container) return;

                if (this.watchlist.length === 0) {
                    container.innerHTML = `
                        <div class="text-center p-4 text-muted-foreground dark:text-dark-muted-foreground">
                            <p class="text-sm">No tickers in watchlist</p>
                            <p class="text-xs mt-1">Add tickers from search results</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = this.watchlist.map(ticker => `
                    <div class="flex items-center justify-between p-3 border-b border-border dark:border-dark-border last:border-b-0"
                         data-watchlist-ticker="${ticker}">
                        <div>
                            <div class="font-semibold text-foreground dark:text-dark-foreground">${ticker}</div>
                            <div class="watchlist-price text-sm text-muted-foreground dark:text-dark-muted-foreground">Loading...</div>
                        </div>
                        <div class="text-right">
                            <div class="watchlist-change text-sm text-muted-foreground dark:text-dark-muted-foreground">-</div>
                            <button class="text-xs text-danger hover:underline mt-1"
                                    onclick="watchlistManager.remove('${ticker}')">Remove</button>
                        </div>
                    </div>
                `).join('');

                // Update prices after UI update
                this.updatePrices();
            }

            startAutoUpdate() {
                if (this.updateInterval) clearInterval(this.updateInterval);
                this.updateInterval = setInterval(() => {
                    this.updatePrices();
                }, config.WATCHLIST_UPDATE_INTERVAL_MS);
            }

            stopAutoUpdate() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
            }
        }

        // Enhanced Quick View with cached data utilization
        class QuickViewManager {
            constructor(apiManager) {
                this.apiManager = apiManager;
                this.cache = new CacheManager(5 * 60 * 1000); // 5 minutes
            }

            async show(ticker) {
                const modal = document.getElementById('quickViewModal');
                const title = document.getElementById('quickViewModalTitle');
                const content = document.getElementById('quickViewModalContent');

                if (!modal || !title || !content) return;

                title.textContent = `Quick View: ${ticker}`;
                content.innerHTML = this.getLoadingHTML();
                modal.classList.remove('hidden');
                modal.classList.add('flex');

                try {
                    // Check if we have cached data from search results
                    let data = this.cache.get(ticker);

                    if (!data) {
                        // Fetch fresh data if not cached
                        data = await this.apiManager.request(`/api/search_tickers?q=${ticker}`);
                        data = data[0]; // Get first result

                        if (data) {
                            this.cache.set(ticker, data);
                        }
                    }

                    if (data) {
                        content.innerHTML = this.renderQuickView(data);
                    } else {
                        content.innerHTML = this.getErrorHTML('No data available');
                    }
                } catch (error) {
                    console.error('Quick view error:', error);
                    content.innerHTML = this.getErrorHTML('Failed to load data');
                }
            }

            getLoadingHTML() {
                return `
                    <div class="space-y-4">
                        <div class="animate-pulse">
                            <div class="h-4 bg-gray-300 rounded w-3/4 mb-2"></div>
                            <div class="h-3 bg-gray-300 rounded w-1/2 mb-4"></div>
                            <div class="grid grid-cols-2 gap-4">
                                <div class="h-8 bg-gray-300 rounded"></div>
                                <div class="h-8 bg-gray-300 rounded"></div>
                            </div>
                        </div>
                    </div>
                `;
            }

            getErrorHTML(message) {
                return `
                    <div class="text-center p-4">
                        <div class="text-danger mb-2">⚠️</div>
                        <p class="text-sm text-muted-foreground dark:text-dark-muted-foreground">${message}</p>
                    </div>
                `;
            }

            renderQuickView(data) {
                return `
                    <div class="space-y-4">
                        <div>
                            <h3 class="text-lg font-semibold text-foreground dark:text-dark-foreground">${data.name || data.ticker}</h3>
                            <p class="text-sm text-muted-foreground dark:text-dark-muted-foreground">${data.sector || 'Unknown Sector'}</p>
                        </div>

                        ${data.price ? `
                            <div class="grid grid-cols-2 gap-4">
                                <div class="bg-muted dark:bg-dark-muted rounded-lg p-3">
                                    <div class="text-xs text-muted-foreground dark:text-dark-muted-foreground">Current Price</div>
                                    <div class="text-lg font-semibold text-foreground dark:text-dark-foreground">$${data.price.toFixed(2)}</div>
                                </div>
                                ${data.percent_change !== undefined ? `
                                    <div class="bg-muted dark:bg-dark-muted rounded-lg p-3">
                                        <div class="text-xs text-muted-foreground dark:text-dark-muted-foreground">Change</div>
                                        <div class="text-lg font-semibold ${data.percent_change >= 0 ? 'text-success' : 'text-danger'}">
                                            ${data.percent_change >= 0 ? '+' : ''}${data.percent_change.toFixed(2)}%
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}

                        ${data.market_cap ? `
                            <div class="bg-muted dark:bg-dark-muted rounded-lg p-3">
                                <div class="text-xs text-muted-foreground dark:text-dark-muted-foreground">Market Cap</div>
                                <div class="text-sm font-semibold text-foreground dark:text-dark-foreground">
                                    $${(data.market_cap / 1e9).toFixed(1)}B
                                </div>
                            </div>
                        ` : ''}

                        <div class="flex gap-2 pt-2">
                            <button class="flex-1 bg-primary text-primary-foreground px-3 py-2 rounded-md text-sm font-medium hover:opacity-90"
                                    onclick="generateReport('${data.ticker}'); hideQuickView();">
                                Generate Report
                            </button>
                            <button class="flex-1 border border-border dark:border-dark-border px-3 py-2 rounded-md text-sm font-medium hover:bg-muted dark:hover:bg-dark-muted"
                                    onclick="watchlistManager.add('${data.ticker}'); hideQuickView();">
                                Add to Watchlist
                            </button>
                        </div>
                    </div>
                `;
            }

            hide() {
                const modal = document.getElementById('quickViewModal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                }
            }
        }

        // Initialize managers
        let searchManager;
        let watchlistManager;
        let quickViewManager;

        // Initialize everything when DOM is loaded
        document.addEventListener('DOMContentLoaded', async function() {
            await config.loadDefaults();

            searchManager = new SearchManager(apiManager, config);
            watchlistManager = new WatchlistManager(apiManager);
            quickViewManager = new QuickViewManager(apiManager);

            // Initialize watchlist
            watchlistManager.updateUI();
            watchlistManager.startAutoUpdate();

            // Initialize market status
            marketStatus.updateStatus();
            setInterval(() => marketStatus.updateStatus(), 60000); // Update every minute

            // Initialize Socket.IO
            initializeSocket();

            // Initial data load
            updateDashboard();
            setInterval(updateDashboard, 10000); // Update every 10 seconds
        });

        // Enhanced search functions
        function updateSearchResults(query) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                const term = (query || '').trim();
                if (term.length < 2) {
                    hideSearchResults();
                    return;
                }

                const container = document.getElementById('searchResults');
                if (!container) return;

                try {
                    const matches = await searchManager.search(term);
                    searchManager.renderResults(matches, container, term);
                    showSearchResults();
                } catch (error) {
                    console.error('Search error:', error);
                    const list = container.querySelector('ul');
                    if (list) {
                        list.innerHTML = '<li class="px-3 py-2 text-danger">Search failed. Please try again.</li>';
                    }
                }
            }, config.SEARCH_DEBOUNCE_MS);
        }

        function selectSearchResult(ticker) {
            const searchInput = document.getElementById('tickerInput');
            if (searchInput) {
                searchInput.value = ticker;
            }
            hideSearchResults();
        }

        function showSearchResults() {
            const container = document.getElementById('searchResults');
            if (container) {
                container.classList.remove('hidden');
            }
        }

        function hideSearchResults() {
            const container = document.getElementById('searchResults');
            if (container) {
                container.classList.add('hidden');
            }
        }

        // Quick view functions
        function showQuickView(ticker) {
            // Cache ticker data if available in search results
            const searchResults = document.querySelectorAll('[data-ticker]');
            searchResults.forEach(element => {
                if (element.dataset.ticker === ticker) {
                    // Extract and cache data from search result
                    const priceElement = element.querySelector('.font-semibold');
                    const nameElement = element.querySelector('.text-sm');

                    if (priceElement && nameElement) {
                        const cachedData = {
                            ticker: ticker,
                            name: nameElement.textContent,
                            price: parseFloat(priceElement.textContent.replace('$', ''))
                        };
                        quickViewManager.cache.set(ticker, cachedData);
                    }
                }
            });

            quickViewManager.show(ticker);
        }

        function hideQuickView() {
            quickViewManager.hide();
        }

        // Enhanced utility functions
        function addToWatchlist(ticker) {
            if (watchlistManager.add(ticker)) {
                showNotification(`${ticker} added to watchlist`, 'success');
            } else {
                showNotification(`${ticker} is already in watchlist`, 'warning');
            }
        }

        function showNotification(message, type = 'info') {
            // Create a simple notification system
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 p-4 rounded-lg shadow-lg z-50 transition-opacity duration-300 ${
                type === 'success' ? 'bg-success text-white' :
                type === 'warning' ? 'bg-warning text-white' :
                type === 'error' ? 'bg-danger text-white' :
                'bg-primary text-primary-foreground'
            }`;
            notification.textContent = message;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            apiManager.cancelAll();
            watchlistManager.stopAutoUpdate();
            if (socket) {
                socket.disconnect();
            }
        });

        // Add the rest of the dashboard functionality here...
        // (The existing functions for reports, socket handling, etc.)

    </script>

    <!-- Rest of the HTML content would go here... -->
    <!-- For brevity, I'm showing the enhanced JavaScript structure -->
    <!-- The actual dashboard HTML structure would remain largely the same -->

</body>
</html>